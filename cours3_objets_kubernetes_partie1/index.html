<!doctype html><html lang=fr dir=ltr><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.121.1"><meta name=generator content="Relearn 5.12.5+tip"><meta name=description content="TP - Intro à k8s"><meta name=author content="Alexandre P."><title>Les objets Kubernetes - Partie 1 - Introduction à Kubernetes</title>
<link href=../cours3_objets_kubernetes_partie1/index.xml rel=alternate type=application/rss+xml title="Les objets Kubernetes - Partie 1 - Introduction à Kubernetes"><link href=../css/fontawesome-all.min.css rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=../css/fontawesome-all.min.css rel=stylesheet></noscript><link href=../css/nucleus.css rel=stylesheet><link href=../css/auto-complete.css rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=../css/auto-complete.css rel=stylesheet></noscript><link href=../css/perfect-scrollbar.min.css rel=stylesheet><link href=../css/fonts.css rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=../css/fonts.css rel=stylesheet></noscript><link href=../css/theme.css rel=stylesheet><link href=../css/theme-blue.css rel=stylesheet id=variant-style><link href=../css/variant.css rel=stylesheet><link href=../css/print.css rel=stylesheet media=print><link href=../css/ie.css rel=stylesheet><script src=../js/url.js></script><script src=../js/variant.js></script><script>window.index_js_url="../index.search.js";var root_url="../",baseUriFull,baseUri=root_url.replace(/\/$/,"");window.T_Copy_to_clipboard="Copier dans le presse-papiers",window.T_Copied_to_clipboard="Copié dans le presse-papiers!",window.T_Copy_link_to_clipboard="Copier le lien dans le presse-papiers",window.T_Link_copied_to_clipboard="Lien copié dans le presse-papiers!",window.T_No_results_found="Aucun résultat trouvé pour "{0}"",window.T_N_results_found="{1} résultats trouvés pour "{0}"",baseUriFull="https://zaggash.github.io/tp-iut-kubernetes/",window.variants&&variants.init(["blue"])</script></head><body class="mobile-support html" data-url=../cours3_objets_kubernetes_partie1/><div id=body class=default-animation><div id=sidebar-overlay></div><div id=toc-overlay></div><nav id=topbar class=highlightable><div><div class=navigation><a class="nav nav-next topbar-link" href=../td2-deployer-wordpress/ title="TD - Deployer Wordpress (&#129106;)"><i class="fas fa-chevron-right fa-fw"></i></a></div><div class=navigation><a class="nav nav-prev topbar-link" href=../td1-installation/ title="TD - Installation et Configuration (&#129104;)"><i class="fas fa-chevron-left fa-fw"></i></a></div><div id=breadcrumbs><span id=sidebar-toggle-span><a href=# id=sidebar-toggle class=topbar-link title='Menu (CTRL+ALT+n)'><i class="fas fa-bars fa-fw"></i></a>
</span><span id=toc-menu title='Table des matières (CTRL+ALT+t)'><i class="fas fa-list-alt fa-fw"></i></span>
<span class=links>Les objets Kubernetes - Partie 1</span></div><div class="default-animation progress"><div class=toc-wrapper><nav id=TableOfContents><ul><li><a href=#lapi-et-les-objets-kubernetes>L&rsquo;API et les Objets Kubernetes</a><ul><li><a href=#la-commande-apply>La commande <code>apply</code></a></li></ul></li><li><a href=#parenthèse--le-yaml>Parenthèse : Le YAML</a></li><li><a href=#syntaxe>Syntaxe</a><ul><li><a href=#syntaxe-de-base-dune-description-yaml-kubernetes>Syntaxe de base d&rsquo;une description YAML Kubernetes</a></li><li><a href=#description-de-plusieurs-ressources>Description de plusieurs ressources</a></li></ul></li></ul><ul><li><ul><li><a href=#les-namespaces>Les namespaces</a></li><li><a href=#les-pods>Les Pods</a></li></ul></li><li><a href=#rappel-sur-quelques-concepts>Rappel sur quelques concepts</a><ul><li><a href=#haute-disponibilité>Haute disponibilité</a></li><li><a href=#répartition-de-charge-load-balancing>Répartition de charge (load balancing)</a></li><li><a href=#healthchecks>Healthchecks</a></li><li><a href=#application-microservices>Application microservices</a></li></ul></li><li><a href=#larchitecture-découplée-des-services-kubernetes>L&rsquo;architecture découplée des services Kubernetes</a><ul><li><a href=#les-deployments-deploy>Les Deployments (deploy)</a></li><li><a href=#les-replicasets-rs>Les ReplicaSets (rs)</a></li><li><a href=#les-services>Les Services</a></li></ul></li><li><a href=#les-autres-types-de-workloads-kubernetes>Les autres types de Workloads Kubernetes</a><ul><li><a href=#jobs>Jobs</a></li><li><a href=#cronjobs>CronJobs</a></li></ul></li></ul></nav></div></div></div></nav><main id=body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><div id=head-tags></div><article class=default><h1 id=les-objets-kubernetes---partie-1>Les objets Kubernetes - Partie 1</h1><h2 id=lapi-et-les-objets-kubernetes>L&rsquo;API et les Objets Kubernetes</h2><p>Utiliser Kubernetes consiste à déclarer des objets grâce à l’API Kubernetes pour décrire l’état souhaité d&rsquo;un cluster : quelles applications ou autres processus exécuter, quelles images elles utilisent, le nombre de replicas, les ressources réseau et disque que vous mettez à disposition, etc.</p><p>On définit des objets généralement via l’interface en ligne de commande et <code>kubectl</code> de deux façons :</p><ul><li>en lançant une commande <code>kubectl run &lt;conteneur> ...</code>, <code>kubectl expose ...</code></li><li>en décrivant un objet dans un fichier YAML ou JSON et en le passant au client <code>kubectl apply -f monpod.yml</code></li></ul><p>Vous pouvez également écrire des programmes qui utilisent directement l’API Kubernetes pour interagir avec le cluster et définir ou modifier l’état souhaité. <strong>Kubernetes est complètement automatisable !</strong></p><h3 id=la-commande-apply>La commande <code>apply</code></h3><p>Kubernetes encourage le principe de l&rsquo;infrastructure-as-code : il est recommandé d&rsquo;utiliser une description YAML et versionnée des objets et configurations Kubernetes plutôt que la CLI.</p><p>Pour cela la commande de base est <code>kubectl apply -f object.yaml</code>.</p><p>La commande inverse <code>kubectl delete -f object.yaml</code> permet de détruire un objet précédement appliqué dans le cluster à partir de sa description.</p><p>Lorsqu&rsquo;on vient d&rsquo;appliquer une description on peut l&rsquo;afficher dans le terminal avec <code>kubectl apply -f myobj.yaml view-last-applied</code></p><p>Globalement Kubernetes garde un historique de toutes les transformations des objets : on peut explorer, par exemple avec la commande <code>kubectl rollout history deployment</code>.</p><h2 id=parenthèse--le-yaml>Parenthèse : Le YAML</h2><p>Kubernetes décrit ses ressources en YAML. A quoi ça ressemble, YAML ?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>marché</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>lieu</span>: <span style=color:#ae81ff>Marché de la Place</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>jour</span>: <span style=color:#ae81ff>jeudi</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>horaire</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>unité</span>: <span style=color:#e6db74>&#34;heure&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>min</span>: <span style=color:#ae81ff>12</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>max</span>: <span style=color:#ae81ff>20</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>fruits</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>nom</span>: <span style=color:#ae81ff>pomme</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>couleur</span>: <span style=color:#e6db74>&#34;verte&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>pesticide</span>: <span style=color:#ae81ff>avec</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      - <span style=color:#f92672>nom</span>: <span style=color:#ae81ff>poires</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>couleur</span>: <span style=color:#ae81ff>jaune</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>pesticide</span>: <span style=color:#ae81ff>sans</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>légumes</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>courgettes</span>
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>salade</span>
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>potiron</span>
</span></span></code></pre></div><h2 id=syntaxe>Syntaxe</h2><ul><li><p>Alignement ! (<strong>2 espaces</strong> !!)</p></li><li><p>ALIGNEMENT !! (comme en python)</p></li><li><p><strong>ALIGNEMENT !!!</strong> (le défaut du YAML, pas de correcteur syntaxique automatique, c&rsquo;est bête mais vous y perdrez forcément du temps !)</p></li><li><p>des listes (tirets)</p></li><li><p>des paires <strong>clé: valeur</strong></p></li><li><p>Un peu comme du JSON, avec cette grosse différence que le JSON se fiche de l&rsquo;alignement et met des accolades et des points-virgules</p></li><li><p><strong>les extensions Kubernetes et YAML dans VSCode vous aident à repérer des erreurs</strong></p></li></ul><h3 id=syntaxe-de-base-dune-description-yaml-kubernetes>Syntaxe de base d&rsquo;une description YAML Kubernetes</h3><p>Les descriptions YAML permettent de décrire de façon lisible et manipulable de nombreuses caractéristiques des ressources Kubernetes (un peu comme un <em>Compose file</em> par rapport à la CLI Docker).</p><h4 id=exemple>Exemple</h4><p>Création d&rsquo;un service simple :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Service</span>
</span></span><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>k8s-app</span>: <span style=color:#ae81ff>kubernetes-dashboard</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>kubernetes-dashboard</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>kubernetes-dashboard</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>port</span>: <span style=color:#ae81ff>443</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>targetPort</span>: <span style=color:#ae81ff>8443</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>k8s-app</span>: <span style=color:#ae81ff>kubernetes-dashboard</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>type</span>: <span style=color:#ae81ff>NodePort</span>
</span></span></code></pre></div><p>Remarques de syntaxe :</p><ul><li>Toutes les descriptions doivent commencer par spécifier la version d&rsquo;API (minimale) selon laquelle les objets sont censés être créés</li><li>Il faut également préciser le type d&rsquo;objet avec <code>kind</code></li><li>Le nom dans <code>metadata:\n name: value</code> est également obligatoire.</li><li>On rajoute généralement une description longue démarrant par <code>spec:</code></li></ul><h3 id=description-de-plusieurs-ressources>Description de plusieurs ressources</h3><ul><li><p>On peut mettre plusieurs ressources à la suite dans un fichier k8s : cela permet de décrire une installation complexe en un seul fichier</p><ul><li>par exemple le dashboard Kubernetes <a href=https://github.com/kubernetes/dashboard/ target=_blank>https://github.com/kubernetes/dashboard/</a></li></ul></li><li><p>L&rsquo;ordre n&rsquo;importe pas car les ressources sont décrites déclarativement c&rsquo;est-à-dire que:</p><ul><li>Les dépendances entre les ressources sont déclarées</li><li>Le control plane de Kubernetes se charge de planifier l&rsquo;ordre correct de création en fonction des dépendances (pods avant le déploiement, rôle avec l&rsquo;utilisateur lié au rôle)</li><li>On préfère cependant les mettre dans un ordre logique pour que les humains puissent les lire.</li></ul></li><li><p>On peut sauter des lignes dans le YAML et rendre plus lisible les descriptions</p></li><li><p>On sépare les différents objets par <code>---</code></p></li></ul><h1 id=objets-de-base>Objets de base</h1><h3 id=les-namespaces>Les namespaces</h3><p>Tous les objets Kubernetes sont rangés dans différents espaces de travail isolés appelés <code>namespaces</code>.</p><p>Cette isolation permet 3 choses :</p><ul><li>ne voir que ce qui concerne une tâche particulière (ne réfléchir que sur une seule chose lorsqu&rsquo;on opère sur un cluster)</li><li>créer des limites de ressources (CPU, RAM, etc.) pour le namespace</li><li>définir des rôles et permissions sur le namespace qui s&rsquo;appliquent à toutes les ressources à l&rsquo;intérieur.</li></ul><p>Lorsqu&rsquo;on lit ou créé des objets sans préciser le namespace, ces objets sont liés au namespace <code>default</code>.</p><p>Pour utiliser un namespace autre que <code>default</code> avec <code>kubectl</code> il faut :</p><ul><li>le préciser avec l&rsquo;option <code>-n</code> : <code>kubectl get pods -n kube-system</code></li><li>créer une nouvelle configuration dans la kubeconfig pour changer le namespace par defaut.</li></ul><p>Kubernetes gère lui-même ses composants internes sous forme de pods et services.</p><ul><li>Si vous ne trouvez pas un objet, essayez de lancer la commande kubectl avec l&rsquo;option <code>-A</code> ou <code>--all-namespaces</code></li></ul><h3 id=les-pods>Les Pods</h3><p>Un Pod est l’unité d’exécution de base d’une application Kubernetes que vous créez ou déployez. Un Pod représente des process en cours d’exécution dans votre Cluster.</p><p>Un Pod encapsule un conteneur (ou souvent plusieurs conteneurs), des ressources de stockage, <strong>une IP réseau unique</strong>, et des options qui contrôlent comment le ou les conteneurs doivent s’exécuter (ex: <em>restart policy</em>). Cette collection de conteneurs et volumes tournent dans le même environnement d&rsquo;exécution mais les processus sont isolés.</p><p>Un Pod représente une unité de déploiement : un petit nombre de conteneurs qui sont étroitement liés et qui partagent :</p><ul><li>les mêmes ressources de calcul</li><li>des volumes communs</li><li>la même IP donc le même nom de domaine</li><li>peuvent se parler sur localhost</li><li>peuvent se parler en IPC</li><li>ont un nom différent et des logs différents</li></ul><p>Chaque Pod est destiné à exécuter une instance unique d’un workload donné. Si vous désirez mettre à l’échelle votre workload, vous devez multiplier le nombre de Pods avec un déploiement.</p><p>Pour plus de détail sur la philosophie des pods, vous pouvez consulter <a href=https://www.mirantis.com/blog/multi-container-pods-and-container-communication-in-kubernetes/ target=_blank>ce bon article</a>.</p><p>Kubernetes fournit un ensemble de commande pour débugger des conteneurs :</p><ul><li><code>kubectl logs &lt;pod-name> -c &lt;conteneur_name></code> (le nom du conteneur est inutile si un seul)</li><li><code>kubectl exec -it &lt;pod-name> -c &lt;conteneur_name> -- bash</code></li><li><code>kubectl attach -it &lt;pod-name></code></li></ul><p>Enfin, pour debugger la sortie réseau d&rsquo;un programme on peut rapidement forwarder un port depuis un pods vers l&rsquo;extérieur du cluster :</p><ul><li><code>kubectl port-forward &lt;pod-name> &lt;port_interne>:&lt;port_externe></code></li><li>C&rsquo;est une commande de debug seulement : pour exposer correctement des processus k8s, il faut créer un service, par exemple avec <code>NodePort</code>.</li></ul><p>Pour copier un fichier dans un pod on peut utiliser: <code>kubectl cp &lt;pod-name>:&lt;/path/to/remote/file> &lt;/path/to/local/file></code></p><p>Pour monitorer rapidement les ressources consommées par un ensemble de processus il existe les commande <code>kubectl top nodes</code> et <code>kubectl top pods</code></p><h5 id=un-manifest-de-pod>Un manifest de Pod</h5><p><code>rancher-demo-pod.yaml</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>rancher-demo-pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>image</span>: <span style=color:#ae81ff>monachus/rancher-demo:latest</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>rancher-demo-container</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>containerPort</span>: <span style=color:#ae81ff>8080</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>name</span>: <span style=color:#ae81ff>http</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>protocol</span>: <span style=color:#ae81ff>TCP</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>image</span>: <span style=color:#ae81ff>redis</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>redis-container</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>containerPort</span>: <span style=color:#ae81ff>6379</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>name</span>: <span style=color:#ae81ff>http</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>protocol</span>: <span style=color:#ae81ff>TCP</span>
</span></span></code></pre></div><h2 id=rappel-sur-quelques-concepts>Rappel sur quelques concepts</h2><h3 id=haute-disponibilité>Haute disponibilité</h3><ul><li>Faire en sorte qu&rsquo;un service ait un &ldquo;uptime&rdquo; élevé.</li></ul><p>On veut que le service soit tout le temps accessible même lorsque certaines ressources manquent :</p><ul><li>elles tombent en panne</li><li>elles sont sorties du service pour mise à jour, maintenance ou modification</li></ul><p>Pour cela on doit avoir des ressources multiples&mldr;</p><ul><li>Plusieurs serveurs</li><li>Plusieurs versions des données</li><li>Plusieurs accès réseau</li></ul><p>Il faut que les ressources disponibles prennent automatiquement le relais des ressources indisponibles.
Pour cela on utilise en particulier:</p><ul><li>des &ldquo;load balancers&rdquo; : aiguillages réseau intelligents</li><li>des &ldquo;healthchecks&rdquo; : une vérification de la santé des applications</li></ul><p>Nous allons voir que Kubernetes intègre automatiquement les principes de load balancing et de healthcheck dans l&rsquo;orchestration de conteneurs</p><h3 id=répartition-de-charge-load-balancing>Répartition de charge (load balancing)</h3><ul><li>Un load balancer : une sorte d&rsquo;<strong>&ldquo;aiguillage&rdquo; de trafic réseau</strong>, typiquement HTTP(S) ou TCP.</li><li>Un aiguillage <strong>intelligent</strong> qui se renseigne sur plusieurs critères avant de choisir la direction.</li></ul><p>Cas d&rsquo;usage :</p><ul><li>Éviter la surcharge : les requêtes sont réparties sur différents backends pour éviter de les saturer.</li></ul><p>L&rsquo;objectif est de permettre la haute disponibilité : on veut que notre service soit toujours disponible, même en période de panne/maintenance.</p><ul><li><p>Donc on va dupliquer chaque partie de notre service et mettre les différentes instances derrière un load balancer.</p></li><li><p>Le load balancer va vérifier pour chaque backend s&rsquo;il est disponible (<strong>healthcheck</strong>) avant de rediriger le trafic.</p></li><li><p>Répartition géographique : en fonction de la provenance des requêtes on va rediriger vers un datacenter adapté (+ proche).</p></li></ul><h3 id=healthchecks>Healthchecks</h3><p>Fournir à l&rsquo;application une façon d&rsquo;indiquer qu&rsquo;elle est disponible, c&rsquo;est-à-dire :</p><ul><li>qu&rsquo;elle est démarrée (<em>liveness</em>)</li><li>qu&rsquo;elle peut répondre aux requêtes (<em>readiness</em>).</li></ul><h3 id=application-microservices>Application microservices</h3><ul><li><p>Une application composée de nombreux petits services communiquant via le réseau. Le calcul pour répondre à une requête est décomposé en différente parties distribuées entre les services. Par exemple:</p></li><li><p>un service est responsable de la gestion des <strong>clients</strong> et un autre de la gestion des <strong>commandes</strong>.</p></li><li><p>Ce mode de développement implique souvent des architectures complexes pour être mis en oeuvre et kubernetes est pensé pour faciliter leur gestion à grande échelle.</p></li><li><p>Imaginez devoir relancer manuellement des services vitaux pour une application en hébergeant des centaines d&rsquo;instances : c&rsquo;est en particulier à ce moment que kubernetes devient indispensable.</p></li></ul><h5 id=2-exemples-dapplication-microservices>2 exemples d&rsquo;application microservices:</h5><ul><li><a href=https://github.com/microservices-patterns/ftgo-application target=_blank>https://github.com/microservices-patterns/ftgo-application</a> -> fonctionne avec le très bon livre <code>Microservices pattern</code> visible sur le readme.</li><li><a href=https://github.com/GoogleCloudPlatform/microservices-demo target=_blank>https://github.com/GoogleCloudPlatform/microservices-demo</a> -> Exemple d&rsquo;application microservice de référence de Google pour Kubernetes.</li></ul><h2 id=larchitecture-découplée-des-services-kubernetes>L&rsquo;architecture découplée des services Kubernetes</h2><p><a href=#image-d4091e1ac6bcc7b745d6ccdc462bb44b class=lightbox-link><img src=./deploy-decoupled-pattern.png alt style=height:auto;width:auto loading=lazy>
</a><a href=javascript:history.back(); class=lightbox id=image-d4091e1ac6bcc7b745d6ccdc462bb44b><img src=./deploy-decoupled-pattern.png alt class=lightbox-image loading=lazy></a></p><p>Comme nous l&rsquo;avons vu dans le TD precedent, déployer une application dans kubernetes demande plusieurs étapes. En réalité en plus des <strong>pods</strong> l&rsquo;ensemble de la gestion d&rsquo;un service applicatif se décompose dans Kubernetes en 3 à 4 objets articulés entre eux:</p><ul><li><strong>replicatset</strong></li><li><strong>deployment</strong></li><li><strong>service</strong></li><li><strong>(ingress)</strong></li></ul><h3 id=les-deployments-deploy>Les Deployments (deploy)</h3><p>Les déploiements sont les objets effectivement créés manuellement lorsqu&rsquo;on déploie une application. Ce sont des objets de plus haut niveau que les <strong>pods</strong> et <strong>replicaset</strong> et les pilote pour gérer un déploiement applicatif.</p><p><a href=#image-7666d626a6cd77a3bd0df1f05c3698fa class=lightbox-link><img src=./wiki-ciscolinux-co-uk-russiandolls.png alt style=height:auto;width:auto loading=lazy>
</a><a href=javascript:history.back(); class=lightbox id=image-7666d626a6cd77a3bd0df1f05c3698fa><img src=./wiki-ciscolinux-co-uk-russiandolls.png alt class=lightbox-image loading=lazy>
</a><em>Les poupées russes Kubernetes : un Deployment contient un ReplicaSet, qui contient des Pods, qui contiennent des conteneurs</em></p><p>S&rsquo;il c&rsquo;est nécessaire d&rsquo;avoir ces trois types de ressources c&rsquo;est parce que Kubernetes respecte un principe de découplage des responsabilités.</p><p>La responsabilité d&rsquo;un déploiement est de gérer la coexistence et le <strong>tracking de versions</strong> multiples d&rsquo;une application et d&rsquo;effectuer des montées de version automatiques en haute disponibilité en suivant une <strong>RolloutStrategy</strong>.</p><p>Ainsi lors des changements de version, un seul <strong>deployment</strong> gère automatiquement de multiples <strong>replicasets</strong> contenant chacun <strong>une version</strong> de l&rsquo;application => Le découplage est nécessaire.</p><p>Un <em>deployment</em> implique la création d&rsquo;un ensemble de Pods désignés par une étiquette <code>label</code> et regroupé dans un <strong>Replicaset</strong>.</p><p>Exemple :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Deployment</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx-deployment</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>app</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>replicas</span>: <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>strategy</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>type</span>: <span style=color:#ae81ff>Recreate</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>app</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>app</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx:1.7.9</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>            - <span style=color:#f92672>containerPort</span>: <span style=color:#ae81ff>80</span>
</span></span></code></pre></div><ul><li><p>Pour les afficher : <code>kubectl get deployments</code></p></li><li><p>La commande <code>kubectl run</code> sert à créer un <em>deployment</em> à partir d&rsquo;un modèle. Il vaut mieux utilisez <code>apply -f</code>.</p></li></ul><h3 id=les-replicasets-rs>Les ReplicaSets (rs)</h3><p>Dans notre modèle, les <strong>ReplicaSet</strong> servent à gérer et sont responsables pour:</p><ul><li><p>la réplication (avoir le bon nombre d&rsquo;instances et le scaling)</p></li><li><p>la santé et le redémarrage automatique des pods de l&rsquo;application (Self-Healing)</p></li><li><p><code>kubectl get rs</code> pour afficher la liste des replicas.</p></li></ul><p>En général on ne les manipule pas directement (c&rsquo;est déconseillé) même s&rsquo;il est possible de les modifier et de les créer avec un fichier de ressource. Pour créer des groupes de conteneurs on utilise soit un <strong>Deployment</strong> soit d&rsquo;autres formes de workloads (<strong>DaemonSet</strong>, <strong>StatefulSet</strong>, <strong>Job</strong>) adaptés à d&rsquo;autres cas.</p><h3 id=les-services>Les Services</h3><p>Dans Kubernetes, un <strong>service</strong> est un objet qui :</p><ul><li>Désigne un ensemble de pods (grâce à des tags) généralement géré par un déploiement.</li><li>Fournit un endpoint réseau pour les requêtes à destination de ces pods.</li><li>Configure une politique permettant d’y accéder depuis l&rsquo;intérieur ou l&rsquo;extérieur du cluster.</li></ul><p>L’ensemble des pods ciblés par un service est déterminé par un <code>selector</code>.</p><p>Par exemple, considérons un backend de traitement d’image (<em>stateless</em>, c&rsquo;est-à-dire ici sans base de données) qui s’exécute avec 3 replicas. Ces replicas sont interchangeables et les frontends ne se soucient pas du backend qu’ils utilisent. Bien que les pods réels qui composent l’ensemble <code>backend</code> puissent changer, les clients frontends ne devraient pas avoir besoin de le savoir, pas plus qu’ils ne doivent suivre eux-mêmes l&rsquo;état de l’ensemble des backends.</p><p>L’abstraction du service permet ce découplage : les clients frontend s&rsquo;addressent à une seule IP avec un seul port dès qu&rsquo;ils ont besoin d&rsquo;avoir recours à un backend. Les backends vont recevoir la requête du frontend aléatoirement.</p><p>Les Services sont de trois types principaux :</p><ul><li><p><code>ClusterIP</code>: expose le service <strong>sur une IP interne</strong> au cluster. Les autres pods peuvent alors accéder au service de l&rsquo;intérieur du cluster, mais il n&rsquo;est pas l&rsquo;extérieur.</p></li><li><p><code>NodePort</code>: expose le service depuis l&rsquo;IP de <strong>chacun des noeuds du cluster</strong> en ouvrant un port directement sur le nœud, entre 30000 et 32767. Cela permet d&rsquo;accéder aux pods internes répliqués. Comme l&rsquo;IP est stable on peut faire pointer un DNS ou Loadbalancer classique dessus.</p></li></ul><p><a href=#image-ceb092c73262cd0dbecfe7b8b6d647e5 class=lightbox-link><img src=./nodeport.png alt style=height:auto;width:auto loading=lazy>
</a><a href=javascript:history.back(); class=lightbox id=image-ceb092c73262cd0dbecfe7b8b6d647e5><img src=./nodeport.png alt class=lightbox-image loading=lazy></a></p><ul><li><code>LoadBalancer</code>: expose le service en externe à l’aide d&rsquo;un Loadbalancer de fournisseur de cloud. Les services NodePort et ClusterIP, vers lesquels le Loadbalancer est dirigé sont automatiquement créés.</li></ul><p><a href=#image-411126cb9fe250512ba146e9d457339e class=lightbox-link><img src=./loadbalancer.png alt style=height:auto;width:auto loading=lazy>
</a><a href=javascript:history.back(); class=lightbox id=image-411126cb9fe250512ba146e9d457339e><img src=./loadbalancer.png alt class=lightbox-image loading=lazy></a></p><h2 id=les-autres-types-de-workloads-kubernetes>Les autres types de Workloads Kubernetes</h2><p><a href=#image-4c0a737f16a0c4c8b0d42390c151eb21 class=lightbox-link><img src=./k8s_objects_hierarchy.png alt style=height:auto;width:auto loading=lazy>
</a><a href=javascript:history.back(); class=lightbox id=image-4c0a737f16a0c4c8b0d42390c151eb21><img src=./k8s_objects_hierarchy.png alt class=lightbox-image loading=lazy></a></p><p>En plus du déploiement d&rsquo;un application, Il existe pleins d&rsquo;autre raisons de créer un ensemble de Pods:</p><ul><li>Le <strong>DaemonSet</strong>: Faire tourner un agent ou démon sur chaque nœud, par exemple pour des besoins de monitoring, ou pour configurer le réseau sur chacun des nœuds.</li><li>Le <strong>Job</strong> : Effectuer une tache unique de durée limitée et ponctuelle, par exemple de nettoyage d&rsquo;un volume ou la préparation initiale d&rsquo;une application, etc.</li><li>Le <strong>CronJob</strong> : Effectuer une tache unique de durée limitée et récurrente, par exemple de backup ou de régénération de certificat, etc.</li></ul><p>De plus même pour faire tourner une application, les déploiements ne sont pas toujours suffisants. En effet ils sont peu adaptés à des applications statefull comme les bases de données de toutes sortes qui ont besoin de persister des données critiques. Pour celà on utilise un <strong>StatefulSet</strong> que nous verrons par la suite.</p><p>Étant donné les similitudes entre les DaemonSets, les StatefulSets et les Deployments, il est important de comprendre un peu précisément quand les utiliser.</p><p>Les <strong>Deployments</strong> (liés à des ReplicaSets) doivent être utilisés :</p><ul><li>lorsque votre application est complètement découplée du nœud</li><li>que vous pouvez en exécuter plusieurs copies sur un nœud donné sans considération particulière</li><li>que l&rsquo;ordre de création des replicas et le nom des pods n&rsquo;est pas important</li><li>lorsqu&rsquo;on fait des opérations <em>stateless</em></li></ul><p>Les <strong>DaemonSets</strong> doivent être utilisés :</p><ul><li>lorsqu&rsquo;au moins une copie de votre application doit être exécutée sur tous les nœuds du cluster (ou sur un sous-ensemble de ces nœuds).</li></ul><p>Les <strong>StatefulSets</strong> doivent être utilisés :</p><ul><li>lorsque l&rsquo;ordre de création des replicas et le nom des pods est important</li><li>lorsqu&rsquo;on fait des opérations <em>stateful</em> (écrire dans une base de données)</li></ul><h3 id=jobs>Jobs</h3><p>Les jobs sont utiles pour les choses que vous ne voulez faire qu&rsquo;une seule fois, comme les migrations de bases de données ou les travaux par lots. Si vous exécutez une migration en tant que Pod dans un deployment:</p><ul><li>Dès que la migration se finit le processus du pod s&rsquo;arrête.</li><li>Le <strong>replicaset</strong> qui détecte que l&rsquo;&ldquo;application&rdquo; s&rsquo;est arrêter va tenter de la redémarrer en recréant le pod.</li><li>Votre tâche de migration de base de données se déroulera donc en boucle, en repeuplant continuellement la base de données.</li></ul><h3 id=cronjobs>CronJobs</h3><p>Comme des jobs, mais se lancent à un intervalle régulier, comme les <code>cron</code> sur les systèmes unix.</p><footer class=footline></footer></article></div></main></div><aside id=sidebar class="default-animation showVisitedLinks"><div id=header-wrapper class=default-animation><div id=header class=default-animation><a id=logo href=https://zaggash.github.io/tp-iut-kubernetes/><img src=https://upload.wikimedia.org/wikipedia/commons/thumb/3/39/Kubernetes_logo_without_workmark.svg/247px-Kubernetes_logo_without_workmark.svg.png alt="k8s logo"></a></div><div class="searchbox default-animation"><i class="fas fa-search" title="Rechercher (CTRL+ALT+f)"></i>
<label class=a11y-only for=search-by>Rechercher</label>
<input data-search-input id=search-by name=search-by class=search-by type=search placeholder=Rechercher...>
<span data-search-clear><i class="fas fa-times"></i></span></div><script>var contentLangs=["fr"]</script><script src=../js/auto-complete.js defer></script><script src=../js/lunr/lunr.min.js defer></script><script src=../js/lunr/lunr.stemmer.support.min.js defer></script><script src=../js/lunr/lunr.multi.min.js defer></script><script src=../js/lunr/lunr.fr.min.js defer></script><script src=../js/search.js defer></script></div><div id=homelinks class=default-animation><ul><li><a class=padding href=../><i class="fas fa-home"></i> Home</a></li></ul></div><div id=content-wrapper class=highlightable><ul class="topics enlarge morespace"><li data-nav-id=/cours1_presentation_kubernetes/><a class=padding href=../cours1_presentation_kubernetes/><b>1. </b>Presentation de Kubernetes<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/cours2_installation_kubernetes/><a class=padding href=../cours2_installation_kubernetes/><b>2. </b>Installer Kubernetes<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/td1-installation/><a class=padding href=../td1-installation/><b>3. </b>TD - Installation et Configuration<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/cours3_objets_kubernetes_partie1/ class=active><a class=padding href=../cours3_objets_kubernetes_partie1/><b>4. </b>Les objets Kubernetes - Partie 1<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/td2-deployer-wordpress/><a class=padding href=../td2-deployer-wordpress/><b>5. </b>TD - Deployer Wordpress<i class="fas fa-check read-icon"></i></a></li></ul><div id=shortcuts><div class="nav-title padding">Aller plus loin</div><ul class=space><li><a class=padding href=https://kubernetes.io/fr/docs/home/><i class="fab fa-book"></i> Documentation Kubernetes</a></li><li><a class=padding href=https://github.com/zaggash/tp-iut-kubernetes><i class="fab fa-github"></i> Dépôt du TP</a></li><li><a class=padding href=https://www.linkedin.com/in/alexandre-pinon/><i class="fab fa-linkedin"></i> Profil Linkedin</a></li></ul></div><div class="padding footermargin footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVisitedLinks showFooter"></div><hr class="padding default-animation footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVisitedLinks showFooter"><div id=prefooter class="footerLangSwitch footerVariantSwitch footerVisitedLinks showVisitedLinks"><ul><li id=select-language-container class=footerLangSwitch><div class="padding select-container"><i class="fas fa-language fa-fw"></i>
<span>&nbsp;</span><div class=select-style><label class=a11y-only for=select-language>Langue</label>
<select id=select-language onchange="location=baseUri+this.value"></select></div><div class=select-clear></div></div></li><li id=select-variant-container class=footerVariantSwitch><div class="padding select-container"><i class="fas fa-paint-brush fa-fw"></i>
<span>&nbsp;</span><div class=select-style><label class=a11y-only for=select-variant>Thème</label>
<select id=select-variant onchange=window.variants&&variants.changeVariant(this.value)><option id=blue value=blue selected>Blue</option></select></div><div class=select-clear></div></div><script>window.variants&&variants.markSelectedVariant()</script></li><li class="footerVisitedLinks showVisitedLinks"><button class=padding onclick=clearHistory()><i class="fas fa-history fa-fw"></i><span>&nbsp;</span>Supprimer l'historique</button></li></ul></div><div id=footer class="footerFooter showFooter"><center><p>Créé pour l'IUT Reims-Chalons-Charleville - Alexandre P.</p></center></div></div></aside><script src=../js/clipboard.min.js defer></script><script src=../js/perfect-scrollbar.min.js defer></script><script>function useMathJax(e){if(!Object.assign)return;window.MathJax=Object.assign(window.MathJax||{},{loader:{load:["[tex]/mhchem"]},startup:{elements:[".math"]},tex:{inlineMath:[["$","$"],["\\(","\\)"]]},options:{enableMenu:!1}},e)}useMathJax(JSON.parse("{}"))</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script src=../js/d3/d3-color.min.js defer></script><script src=../js/d3/d3-dispatch.min.js defer></script><script src=../js/d3/d3-drag.min.js defer></script><script src=../js/d3/d3-ease.min.js defer></script><script src=../js/d3/d3-interpolate.min.js defer></script><script src=../js/d3/d3-selection.min.js defer></script><script src=../js/d3/d3-timer.min.js defer></script><script src=../js/d3/d3-transition.min.js defer></script><script src=../js/d3/d3-zoom.min.js defer></script><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js defer></script><script>window.themeUseMermaid=JSON.parse('{ "theme": "default" }')</script><script src=https://cdn.jsdelivr.net/npm/rapidoc/dist/rapidoc-min.js defer></script><script>window.themeUseSwagger=JSON.parse('{ "theme": "light" }')</script><script src=../js/theme.js defer></script></body></html>